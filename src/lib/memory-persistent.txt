// lib/memory.ts — VERSION NETTOYÉE (classification immédiate)
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

type MemoryRole = "user" | "assistant";

// ✅ Prompt mémoire filtrée, propre
const memoryFilterPrompt = `
You are a memory filter AI.

Your task is to decide if a user message contains clear and specific personal information that helps build an understanding of the user over time — such as facts about their identity, preferences, values, emotions, routines, lifestyle, worldview, or experiences — and that could be remembered to personalize future interactions.

Mark it as "persistent" if it includes:
• Anything about their name, age, gender, or where they live
• Preferences or attachments to places (city, country, climate, dream destination, or fictional worlds)
• Personal tastes (food, music, aesthetics, fashion, etc.)
• Emotional expressions, habits, routines, or experiences
• Physical traits, body goals, style, or health info
• Relationship status, history, expectations, libido, etc.
• Opinions or ideas that seem tied to their identity or worldview

Mark it as "short" only if:
• It’s clearly a generic question, a joke, or unrelated to the user's self
• It’s vague and has no personal element
• It’s purely about external topics with no self-reference

Reply strictly with: \`yes\` or \`no\` only.
`.trim();

/**
 * Lecture mémoire intelligente :
 * - 1) Tente de répondre avec les 20 derniers SHORT
 * - 2) Sinon, regarde dans PERSISTENT
 * - 3) Sinon, renvoie []
 */
export async function getRelevantMemories(userId: string, userMessage: string) {
  const { data: short } = await supabase
    .from("memories")
    .select("role, content")
    .eq("user_id", userId)
    .eq("layer", "short")
    .order("created_at", { ascending: true });

  const { data: persistent } = await supabase
    .from("memories")
    .select("role, content")
    .eq("user_id", userId)
    .eq("layer", "persistent")
    .order("created_at", { ascending: true });

  return [...(persistent ?? []), ...(short ?? [])];
}

/**
 * ⬇️ NOUVELLE LOGIQUE (remplace l'ancienne promotion différée) ⬇️
 * - Analyse immédiate du message reçu via GPT-4o
 * - Classement direct: 'persistent' si "yes", sinon 'short'
 * - Insertion unique (pas de duplication, pas de promotion ultérieure)
 */
export async function storeInShort(
  userId: string,
  role: MemoryRole,
  content: string
) {
  // 1) GPT-4o évalue le message courant
  let layer: "short" | "persistent" = "short";
  try {
    const evalResp = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0,
      messages: [
        { role: "system", content: memoryFilterPrompt },
        { role: "user", content },
      ],
    });

    const verdict = String(evalResp.choices?.[0]?.message?.content ?? "")
      .trim()
      .toLowerCase();

    if (verdict === "yes") {
      layer = "persistent";
    } else {
      layer = "short";
    }
  } catch (e) {
    // En cas d'échec OpenAI, on tombe en 'short' pour ne jamais perdre le message
    console.warn("⚠️ OpenAI eval failed — defaulting to 'short'", e);
    layer = "short";
  }

  // 2) Insertion unique dans la couche décidée par GPT-4o
  const ins = await supabase.from("memories").insert({
    user_id: userId,
    role,
    content,
    layer,
  });

  if (ins.error) {
    console.error("❌ insert memory failed", {
      userId,
      role,
      layer,
      preview: content.slice(0, 120),
      error: ins.error,
    });
    throw ins.error;
  }
}
