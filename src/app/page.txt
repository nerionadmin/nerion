'use client';
import { Mic, Volume2, Upload, LogOut, Sun, Moon, Menu, X } from 'lucide-react';
import Image from 'next/image';
import { useState, useRef, useEffect } from 'react';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { useTheme } from 'next-themes';
import Logo from "@/components/Logo";
import TypingDots from "../components/TypingDots";


// Petit type local pour l'√©v√©nement de MediaRecorder
type DataAvailableEvent = { data: Blob };

// ‚ûï Helper pour retirer le gras Markdown (**‚Ä¶**)
const stripMdEmphasis = (s: string) => s.replace(/\*\*(.*?)\*\*/g, '$1');

// ‚úÖ Typage propre pour webkitAudioContext
declare global {
  interface Window {
    webkitAudioContext?: typeof AudioContext;
  }
}

export default function Home() {
  const [messages, setMessages] = useState<string[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [recording, setRecording] = useState(false);
  const [isSpeakerOn, setIsSpeakerOn] = useState(false);
  const [audioUnlocked, setAudioUnlocked] = useState(false);
  const autoResize = (el: HTMLTextAreaElement) => {
  const MIN = 40; // px (hauteur de base)
  const MAX = 240; // px (‚âà max-h-60)
  el.style.height = 'auto';
  const needed = el.scrollHeight;
  const newH = Math.max(Math.min(needed, MAX), MIN);
  el.style.height = newH + 'px';
  el.style.overflowY = needed > MAX ? 'auto' : 'hidden';
};

  // üéõÔ∏è UI: niveau de voix (0 ‚Üí 1) pour afficher des vibrations dans la barre de recherche
  const [voiceLevel, setVoiceLevel] = useState(0);

  // √âtats/refs pour la capture audio + VAD
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const audioCtxRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const dataArrayRef = useRef<Uint8Array | null>(null);
  const rafIdRef = useRef<number | null>(null);
  const userIsSpeakingRef = useRef(false);
  const lastVoiceTsRef = useRef<number>(0);

  const bottomRef = useRef<HTMLDivElement>(null);

  // üîä Lecture audio fiable (une seule instance)
  const currentAudioRef = useRef<HTMLAudioElement | null>(null);
  const isSpeakingRef = useRef<boolean>(false);

  const USER_ID = 'demo_user_1'; // provisoire

  // ‚õîÔ∏è Gate d‚Äôauth
  const supabase = createClientComponentClient();
  // ‚¨áÔ∏è √âchange ?code=... -> session (cookies sb-...) ‚Äî version corrig√©e
  useEffect(() => {
    if (typeof window === "undefined") return;
    const url = new URL(window.location.href);
    const code = url.searchParams.get("code");
    if (!code) return;

    supabase.auth.exchangeCodeForSession(code)
      .then(() => {
        // on nettoie l‚ÄôURL (retire code/state pour √©viter de relancer l‚Äô√©change)
        url.searchParams.delete("code");
        url.searchParams.delete("state");
        window.history.replaceState({}, "", url.toString());
      })
      .catch(() => {});
  }, [supabase]);
  // ‚¨ÜÔ∏è AJOUT UNIQUE

  const [isAuthed, setIsAuthed] = useState<boolean | null>(null);
  useEffect(() => {
    let mounted = true;
    supabase.auth
      .getUser()
      .then(({ data }) => mounted && setIsAuthed(!!data.user))
      .catch(() => mounted && setIsAuthed(false));
    const { data: listener } = supabase.auth.onAuthStateChange((_e, session) => {
      setIsAuthed(!!session?.user);
    });
    return () => {
      mounted = false;
      listener.subscription.unsubscribe();
    };
  }, [supabase]);

  // üîΩüîΩüîΩ UNIQUE MODIF ICI : handler du bouton Google (ajout queryParams)
  const handleGoogleLogin = async () => {
    const origin =
      typeof window !== 'undefined' && window.location?.origin
        ? window.location.origin
        : undefined;

    await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: origin,
        queryParams: {
          prompt: 'consent',
          access_type: 'offline',
        },
      },
    });
  };
  // üîºüîºüîº UNIQUE MODIF ICI

  // ‚úÖ Helpers storage pour √©viter les erreurs "load/save" (Safari priv√©, iFrame, etc.)
  const safeStorage = {
    get: (k: string) => {
      try { if (typeof window === 'undefined' || !window.sessionStorage) return null; return window.sessionStorage.getItem(k); } catch { return null; }
    },
    set: (k: string, v: string) => {
      try { if (typeof window === 'undefined' || !window.sessionStorage) return; window.sessionStorage.setItem(k, v); } catch { /* no-op */ }
    },
    remove: (k: string) => {
      try { if (typeof window === 'undefined' || !window.sessionStorage) return; window.sessionStorage.removeItem(k); } catch { /* no-op */ }
    },
  };

  // ‚úÖ Logout : coupe audio + vide l'UI + purge la session locale + redirige vers page neutre
  const handleLogout = async () => {
    try {
      await stopRecordingAndCleanup(); // coupe micro/lectures si besoin
      await supabase.auth.signOut({ scope: 'global' });
      safeStorage.remove("chatMessages"); // supprime l'historique persistant c√¥t√© navigateur
      setMessages([]);                    // vide l'affichage du chat
      setIsAuthed(false);
      // √©vite un √©ventuel relog via ?code=... / rafra√Æchissement d'√©tat OAuth
      if (typeof window !== 'undefined') window.location.assign('/');
    } catch (e) {
      console.error('Erreur logout:', e);
    }
  };

  const handleSubmit = async (customInput?: string) => {
  const promptToSend = customInput ?? input;
  if (!promptToSend.trim()) return;

  const userMessage = `üß† ${promptToSend}`;
  setMessages((prev) => [...prev, userMessage]);
  setHasSentMessage(true);
  setInput('');
  setLoading(true);

  try {
    const { data: { session } } = await supabase.auth.getSession();
    const token = session?.access_token;

    const response = await fetch('/api/ask', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
      body: JSON.stringify({ message: promptToSend }),
    });

    const data: { message?: string } = await response.json();

    if (response.ok && data.message) {
      setMessages((prev) => [...prev, 'ü§ñ ']);

      // Retire tout bloc JSON (signal, score, etc.) du texte affich√©/parl√©
      const cleaned = (data.message ?? '')
  .replace(/```json[\s\S]*?```/g, '')
  .replace(/\{\s*"trigger_orchestrator"\s*:\s*true\s*\}/g, '')
  .replace(/\{\s*"score"\s*:\s*[1-5]\s*\}/g, '')
  .replace(/\[\[\s*SCORE\s*=\s*[1-5]\s*\]\]/g, '')
  .trim();

      const replyText = stripMdEmphasis(cleaned);

      let i = 0;
      const interval = setInterval(() => {
        setMessages((prev) => {
          const updated = prev.slice(0, -1);
          return [...updated, 'ü§ñ ' + replyText.slice(0, i)];
        });
        i++;
        if (i > replyText.length) clearInterval(interval);
      }, 30);

      await stopRecordingAndCleanup();
      speak(replyText);
    } else {
      setMessages((prev) => [...prev, '‚ùå R√©ponse invalide']);
    }
  } catch (error: unknown) {
    console.error(error);
    setMessages((prev) => [...prev, '‚ö†Ô∏è Une erreur est survenue']);
  }

  setLoading(false);
};

  const speak = async (text: string) => {
    if (!isSpeakerOn) return;
    if (!text || !text.trim()) return;

    try {
      if (!audioUnlocked) {
        unlockAudioContext();
      }

      if (currentAudioRef.current) {
        try {
          currentAudioRef.current.pause();
        } catch {
          // ignore
        }
        currentAudioRef.current.src = '';
        currentAudioRef.current = null;
      }
      if (isSpeakingRef.current) {
        isSpeakingRef.current = false;
      }

      const res = await fetch('/api/voice', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });

      if (!res.ok) {
        console.error('Erreur API ElevenLabs:', await res.text().catch(() => ''));
        return;
      }

      const blob = await res.blob();
      const audioUrl = URL.createObjectURL(blob);
      const audio = new Audio(audioUrl);
      currentAudioRef.current = audio;
      isSpeakingRef.current = true;

      audio.onended = () => {
        if (currentAudioRef.current === audio) {
          currentAudioRef.current = null;
        }
        isSpeakingRef.current = false;
        URL.revokeObjectURL(audioUrl);
      };

      audio.onerror = () => {
        isSpeakingRef.current = false;
      };

      await audio.play().catch((e) => {
        // Si le navigateur bloque la lecture auto, l‚Äôutilisateur devra recliquer le bouton HP
        console.error('Lecture audio bloqu√©e/erreur:', e);
      });
    } catch (err) {
      console.error('Erreur audio :', err);
      isSpeakingRef.current = false;
    }
  };

  // üîá Coupe le micro + lib√®re les ressources (stream, AudioContext, RAF)
  const stopRecordingAndCleanup = async () => {
    try {
      if (mediaRecorderRef.current?.state === 'recording') {
        mediaRecorderRef.current.stop();
      }
    } catch {
      // ignore
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((t) => t.stop());
      streamRef.current = null;
    }

    if (rafIdRef.current) {
      cancelAnimationFrame(rafIdRef.current);
      rafIdRef.current = null;
    }

    if (audioCtxRef.current) {
      try {
        await audioCtxRef.current.close();
      } catch {
        // ignore
      }
      audioCtxRef.current = null;
    }

    analyserRef.current = null;
    dataArrayRef.current = null;
    userIsSpeakingRef.current = false;
    setVoiceLevel(0);
    setRecording(false);
  };

  // üé§ Clic micro ‚Üí enregistre, waveform, auto-stop quand tu as fini de parler (silence)
  const handleVoiceInput = async () => {
    if (recording) return;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;

      // 1) MediaRecorder pour capturer l'audio (envoi √† /api/transcribe)
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      const audioChunks: Blob[] = [];

      mediaRecorder.ondataavailable = (event: DataAvailableEvent) => {
        if (event.data && event.data.size > 0) audioChunks.push(event.data);
      };

      mediaRecorder.onstop = async () => {
        setRecording(false);
        await stopVADLoop();

        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('audio', audioBlob);

        try {
          const res = await fetch('/api/transcribe', {
            method: 'POST',
            body: formData,
          });

          const data: { text?: string } = await res.json();
          if (data.text && data.text.trim()) {
            await handleSubmit(data.text.trim());
          } else {
            setMessages((prev) => [...prev, '‚ùå √âchec de transcription']);
          }
        } catch (err) {
          console.error('Erreur transcription', err);
          setMessages((prev) => [...prev, '‚ö†Ô∏è Erreur serveur transcription']);
        }
      };

      mediaRecorder.start();
      setRecording(true);

      // 2) D√©marrer VAD (d√©tection de voix) pour: waveform + stopper au silence
      startVADLoop(stream);
    } catch (error) {
      console.error('Erreur micro', error);
      alert("Erreur lors de l'acc√®s au micro.");
      setRecording(false);
    }
  };

  // üß† VAD simple via WebAudio (RMS) + seuil + timeout de silence
  const startVADLoop = (stream: MediaStream) => {
    const SILENCE_HOLD_MS = 2000;
    const VOICE_THRESHOLD = 0.02;

    const AudioContextCtor =
      typeof window !== 'undefined'
        ? window.AudioContext || window.webkitAudioContext
        : undefined;

    if (!AudioContextCtor) {
      console.error('AudioContext non support√©.');
      return;
    }

    const audioCtx = new AudioContextCtor();
    audioCtxRef.current = audioCtx;

    const source = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;

    const bufferLength = analyser.fftSize;
    const dataArray = new Uint8Array(bufferLength);

    analyserRef.current = analyser;
    dataArrayRef.current = dataArray;

    source.connect(analyser);

    lastVoiceTsRef.current = performance.now();

    const tick = () => {
      analyser.getByteTimeDomainData(dataArray);

      let sumSquares = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] - 128) / 128;
        sumSquares += v * v;
      }
      const rms = Math.sqrt(sumSquares / dataArray.length);

      setVoiceLevel(Math.min(1, rms * 6));

      const now = performance.now();
      if (rms > VOICE_THRESHOLD) {
        userIsSpeakingRef.current = true;
        lastVoiceTsRef.current = now;
      } else {
        if (userIsSpeakingRef.current && now - lastVoiceTsRef.current > SILENCE_HOLD_MS) {
          if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
            mediaRecorderRef.current.stop();
          }
          return;
        }
      }

      rafIdRef.current = requestAnimationFrame(tick);
    };

    rafIdRef.current = requestAnimationFrame(tick);
  };

  const stopVADLoop = async () => {
    if (rafIdRef.current) {
      cancelAnimationFrame(rafIdRef.current);
      rafIdRef.current = null;
    }
    if (audioCtxRef.current) {
      try {
        await audioCtxRef.current.close();
      } catch {
        // ignore
      }
      audioCtxRef.current = null;
    }
    analyserRef.current = null;
    dataArrayRef.current = null;
    userIsSpeakingRef.current = false;
    setVoiceLevel(0);

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((t) => t.stop());
      streamRef.current = null;
    }
  };

  const unlockAudioContext = () => {
    if (audioUnlocked) return;

    const audio = new Audio();
    audio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
    audio.play().catch(() => {});
    setAudioUnlocked(true);
  };

  // ‚ôªÔ∏è Au montage : si un cache existe, on r√©hydrate l'UI
  useEffect(() => {
    try {
      const saved = safeStorage.get("chatMessages");
      if (saved) {
        const parsed = JSON.parse(saved);
        if (Array.isArray(parsed)) setMessages(parsed);
      }
    } catch {
      // silencieux
    }
  }, []);

  // üíæ √Ä chaque update : on sauvegarde en session + on scrolle en bas
  useEffect(() => {
    try {
      safeStorage.set("chatMessages", JSON.stringify(messages));
    } catch {
      // silencieux
    }
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // === NEW: refs + trigger pour upload image ===
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const triggerImagePicker = () => fileInputRef.current?.click();

  // === NEW: handler image ‚Üí Supabase ‚Üí /api/ask ===
  const handleImagePicked = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setHasSentMessage(true);

    setLoading(true); // üëà Active le spinner du bouton Envoyer

    // placeholder dans le chat
    setMessages((prev) => [...prev, 'üñºÔ∏è Envoi de la photo‚Ä¶']);

    try {
      // 1) r√©cup√©rer l'utilisateur (obligatoire pour le dossier /<uid>/ )
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        alert("Tu dois √™tre connect√© pour envoyer une photo.");
        setIsAuthed(false);
        return;
      }

      // 2) upload sous /<uid>/...  (compatible avec la policy SELECT par utilisateur)
      const filePath = `${user.id}/${Date.now()}-${file.name}`;
      const { error: uploadErr } = await supabase.storage.from('photos').upload(filePath, file);
      if (uploadErr) throw uploadErr;

      // 3) URL sign√©e (bucket priv√©) ‚Äî valable 1h
      const { data: signed, error: signErr } = await supabase.storage
        .from('photos')
        .createSignedUrl(filePath, 60 * 60);
      if (signErr) throw signErr;

      const imageUrl = signed.signedUrl;

      // ‚ö†Ô∏è Remplacer le placeholder par la vraie image dans le chat
      setMessages((prev) => {
        const updated = prev.slice(0, -1); // enl√®ve "üñºÔ∏è Envoi de la photo‚Ä¶"
        return [...updated, imageUrl];      // ajoute l‚ÄôURL sign√©e ‚Üí affich√©e en <img>
      });

      // 3) /api/ask multimodal
      const { data: { session } } = await supabase.auth.getSession();
      const token = session?.access_token;

      const res = await fetch('/api/ask', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
        },
        body: JSON.stringify({
          content: [{ type: 'image_url', image_url: { url: imageUrl } }],
        }),
      });

      const data: { message?: string } = await res.json();

      if (res.ok && data.message) {
        setMessages((prev) => [...prev, 'ü§ñ ']);
        // Retire tout bloc JSON (signal) du message affich√©/parl√©
const cleaned = (data.message ?? '')
  .replace(/```json[\s\S]*?```/g, '')
  .replace(/\{\s*"trigger_orchestrator"\s*:\s*true\s*\}/g, '')
  .replace(/\{\s*"score"\s*:\s*[1-5]\s*\}/g, '')
  .replace(/\[\[\s*SCORE\s*=\s*[1-5]\s*\]\]/g, '')
  .trim();

const replyText = stripMdEmphasis(cleaned);

        let i = 0;
        const interval = setInterval(() => {
          setMessages((prev) => {
            const updated = prev.slice(0, -1);
            return [...updated, 'ü§ñ ' + replyText.slice(0, i)];
          });
          i++;
          if (i > replyText.length) clearInterval(interval);
        }, 30);

        await stopRecordingAndCleanup();
        speak(replyText);
      } else {
        setMessages((prev) => [...prev, '‚ùå R√©ponse invalide (image)']);
      }
    } catch (err) {
      console.error('Upload/Analyse image', err);
      setMessages((prev) => prev.slice(0, -1));
      setMessages((prev) => [...prev, '‚ö†Ô∏è Erreur pendant l‚Äôenvoi de la photo']);
    } finally {
      if (fileInputRef.current) fileInputRef.current.value = '';
      setLoading(false); // üëà D√©sactive le spinner du bouton Envoyer
    }
  };

  const VoiceMeter = ({ level, active }: { level: number; active: boolean }) => {
    if (!active) return null;

    const width = 200;
    const height = 20;
    const points = Array.from({ length: width }, (_, i) => {
      const angle = (i / width) * Math.PI * 2;
      const y = Math.sin(angle + Date.now() / 180) * level * 6 + height / 2;
      return `${i},${y.toFixed(2)}`;
    }).join(' ');

    return (
      <svg
        viewBox={`0 0 ${width} ${height}`}
        className="absolute right-3 top-1/2 -translate-y-1/2 opacity-0 animate-fadeIn"
      >
        <polyline
          points={points}
          fill="none"
          stroke="var(--ring)"
          strokeWidth="1.2"
          strokeLinejoin="round"
          strokeLinecap="round"
        />
        <style jsx>{`
          @keyframes fadeIn {
            from {
              opacity: 0;
              transform: translateY(-50%) scaleY(0.9);
            }
            to {
              opacity: 1;
              transform: translateY(-50%) scaleY(1);
            }
          }
          .animate-fadeIn {
            animation: fadeIn 250ms ease-out forwards;
          }
        `}</style>
      </svg>
    );
  };

  // === Theme toggle (Sun/Moon) ===
  const { theme, setTheme } = useTheme();
  const [hasSentMessage, setHasSentMessage] = useState(false);
  const [mountedTheme, setMountedTheme] = useState(false);
  const [drawerOpen, setDrawerOpen] = useState(false);
  useEffect(() => setMountedTheme(true), []);

  return (
  <main className="flex flex-col h-screen bg-[var(--bg)] text-[var(--text)] sm:pl-14">

    <aside className="hidden sm:flex flex-col group fixed left-0 top-0 z-30 h-full w-[85px] hover:w-56 transition-[width] duration-200 ease-out bg-[var(--surface-2)] border-r border-[var(--border)]">
  {/* Haut du tiroir */}
  <div className="py-3 space-y-3">
    {/* Logo centr√© dans la colonne fixe (ancr√© √† gauche, ne bouge pas √† l'ouverture) */}
    <div className="w-[85px] flex items-center justify-center">
      <Logo symbolOnly className="h-logo-md w-auto fill-black dark:fill-white" />
    </div>
  </div>

  {/* Bas du tiroir : Th√®me + Logout (centr√©s dans la colonne fixe, ne bougent pas) */}
  <div className="mt-auto w-full pb-10">
    {/* Bouton th√®me : ic√¥ne centr√©e, label √† droite sans pousser l'ic√¥ne */}
    <div className="relative w-[85px] flex justify-center mb-10">
      <button
  onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
  className="flex items-center text-[var(--text-muted)] hover:text-[var(--text)] transition-colors"
  title="Basculer le th√®me"
  aria-label="Basculer le th√®me"
>
  {!mountedTheme ? (
    // Placeholder neutre (m√™me taille), invisible => pas de d√©calage, pas de mismatch
    <span className="block h-7 w-7 opacity-0" aria-hidden="true" />
  ) : theme === 'dark' ? (
    <Sun className="h-7 w-7" />
  ) : (
    <Moon className="h-7 w-7" />
  )}
</button>
      <span className="absolute left-[100%] top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity text-sm">
      </span>
    </div>

    {/* Ic√¥ne centr√©e, label √† droite sans d√©placer l'ic√¥ne */}
    <div className="relative w-[85px] flex justify-center">
      <button
        onClick={handleLogout}
        className="flex items-center text-[var(--text-muted)] hover:text-[var(--text)] transition-colors"
        title="Se d√©connecter"
        aria-label="Se d√©connecter"
      >
        <LogOut className="h-8 w-8" />
      </button>
      <span className="absolute left-[100%] top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity text-sm">
      </span>
    </div>
  </div>
</aside>

      <header className="relative text-center px-4 py-6">
  <div className="flex justify-center items-center" />

  {/* üîò Hamburger (mobile) */}
  <button
    onClick={() => setDrawerOpen(true)}
    className="sm:hidden absolute top-4 left-4 h-14 w-14 rounded-lg flex items-center justify-center transition bg-[var(--surface-2)] text-[var(--text-muted)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)]"
    title="Ouvrir le menu"
    aria-label="Ouvrir le menu"
  >
    <Menu size={22} />
  </button>
</header>

    {!hasSentMessage ? (
  <div className="flex flex-1 flex-col items-center justify-center px-4 text-center max-h-[80vh]">
    <Logo className="h-logo-md w-auto mb-6 fill-black dark:fill-white" />
    <div className="w-full max-w-3xl mx-auto bg-[var(--surface-2)] rounded-xl shadow-inner grid grid-rows-[auto_auto]">
  {/* Ligne TEXTE */}
  <div className="px-4 pt-3">
    <textarea
      value={input}
      onChange={(e) => { setInput(e.target.value); autoResize(e.currentTarget); }}
      onInput={(e) => autoResize(e.currentTarget)}
      onPaste={(e) => autoResize(e.currentTarget)}
      onKeyDown={(e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSubmit(); }
      }}
      placeholder="Pose ta question..."
      rows={1}
      className="block w-full resize-none bg-transparent text-[var(--text)] placeholder-[var(--placeholder)] focus:outline-none text-base sm:text-lg leading-relaxed max-h-60 overflow-y-auto"
      style={{ height: 40 }}
    />
  </div>

  {/* Ligne BOUTONS (fixe) */}
  <div className="px-2 py-2 flex items-center justify-end gap-2">
    <button
  onClick={handleVoiceInput}
  className={`h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out ${
    recording
      ? 'bg-[var(--danger)] text-white border-transparent'
      : 'bg-[var(--surface-2)] text-[var(--text)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm'
  }`}
  aria-label="Dicter" title="Dicter"
>
  <Mic size={20} />
</button>

    <button
  onClick={() => { setIsSpeakerOn(!isSpeakerOn); unlockAudioContext(); }}
  className={`h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out bg-[var(--surface-2)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm ${isSpeakerOn ? 'text-[var(--ring)]' : 'text-[var(--text)]'}`}
  aria-label="Haut-parleur" title="Haut-parleur"
>
  <Volume2 size={20} />
</button>

    <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleImagePicked} />
    <button
  onClick={triggerImagePicker}
  className="h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out bg-[var(--surface-2)] text-[var(--text)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm"
  aria-label="Envoyer une image" title="Envoyer une image"
>
  <Upload size={20} />
</button>
  </div>
</div>
  </div>
) : (
  <>
    <section className="flex-1 overflow-y-auto px-4 py-6 sm:px-6">
      <div className="flex flex-col gap-4 max-w-3xl mx-auto min-h-full">
        {messages.map((msg: string, i: number) => {
  const isImage = msg.startsWith("http");
  const isUser = msg.startsWith("üß† ");
  const clean = isImage ? msg : msg.replace(/^(üß†|ü§ñ)\s?/, "");

  // üñºÔ∏è Images : centr√©es, largeur de lecture
  if (isImage) {
    return (
      <div key={i} className="w-full">
        <div className="max-w-3xl mx-auto">
          <div className="flex justify-center">
            <img
              src={clean}
              alt="Uploaded"
              className="max-w-full max-h-[600px] rounded-lg object-contain border border-[var(--image-border)]"
            />
          </div>
        </div>
      </div>
    );
  }

  // üßë‚Äçüíª Utilisateur : bulle √† droite (couleurs existantes conserv√©es)
  if (isUser) {
    return (
      <div key={i} className="w-full">
        <div className="max-w-md ml-auto">
          <div className="bg-[var(--surface-2)] text-[var(--text)] p-4 rounded-md whitespace-pre-wrap break-words">
            {clean}
          </div>
        </div>
      </div>
    );
  }

  // ü§ñ IA : texte √† plat, centr√©, sans bulle
  return (
    <div key={i} className="w-full">
      <div className="text-[var(--text)] whitespace-pre-wrap break-words leading-relaxed px-1">
  {clean}
</div>
    </div>
  );
})}

{hasSentMessage && loading && (
  <div className="w-full">
    <div className="max-w-3xl mx-auto">
      <TypingDots />
    </div>
  </div>
)}

        <div ref={bottomRef} />
      </div>
    </section>

    {/* ‚úÖ Barre D‚ÄôINPUT EN BAS (apr√®s 1er message) */}
    <div className="px-4 pt-2 pb-6 sm:px-6">
      <div className="w-full max-w-3xl mx-auto bg-[var(--surface-2)] rounded-xl shadow-inner grid grid-rows-[auto_auto]">
  {/* Ligne TEXTE */}
  <div className="px-4 pt-3">
    <textarea
      value={input}
      onChange={(e) => { setInput(e.target.value); autoResize(e.currentTarget); }}
      onInput={(e) => autoResize(e.currentTarget)}
      onPaste={(e) => autoResize(e.currentTarget)}
      onKeyDown={(e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSubmit(); }
      }}
      placeholder="Pose ta question..."
      rows={1}
      className="block w-full resize-none bg-transparent text-[var(--text)] placeholder-[var(--placeholder)] focus:outline-none text-base sm:text-lg leading-relaxed max-h-60 overflow-y-auto"
      style={{ height: 40 }}
    />
  </div>

  {/* Ligne BOUTONS (fixe) */}
  <div className="px-2 py-2 flex items-center justify-end gap-2">
    <button
  onClick={handleVoiceInput}
  className={`h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out ${
    recording
      ? 'bg-[var(--danger)] text-white border-transparent'
      : 'bg-[var(--surface-2)] text-[var(--text)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm'
  }`}
  aria-label="Dicter" title="Dicter"
>
  <Mic size={20} />
</button>

    <button
  onClick={() => { setIsSpeakerOn(!isSpeakerOn); unlockAudioContext(); }}
  className={`h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out bg-[var(--surface-2)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm ${isSpeakerOn ? 'text-[var(--ring)]' : 'text-[var(--text)]'}`}
  aria-label="Haut-parleur" title="Haut-parleur"
>
  <Volume2 size={20} />
</button>

    <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleImagePicked} />
    <button
  onClick={triggerImagePicker}
  className="h-10 w-10 flex items-center justify-center rounded-lg border transition-all duration-200 ease-out bg-[var(--surface-2)] text-[var(--text)] border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm"
  aria-label="Envoyer une image" title="Envoyer une image"
>
  <Upload size={20} />
</button>
  </div>
</div>
    </div>
  </>
)}

      {/* üîí Overlay d‚Äôauth gris√© (pas flout√©). Bloque l‚ÄôUI tant que non connect√©. */}
      {isAuthed === false && (
        <div className="fixed inset-0 z-50">
          {/* voile gris */}
          <div className="absolute inset-0 bg-[var(--scrim-60)]" />
          {/* carte centrale */}
          <div className="relative z-10 flex items-center justify-center h-full p-4">
            <div className="w-full max-w-md bg-[color-mix(in_srgb,var(--bg)_95%,transparent)] border border-[var(--border)] rounded-2xl shadow-2xl p-6 text-center">
              {!hasSentMessage && (
  <div className="flex justify-center mt-10 mb-6">
    <Logo className="h-16 w-auto fill-black dark:fill-white" />
  </div>
)}
              <h2 className="text-xl font-semibold mb-2">Connecte-toi pour continuer</h2>
              <p className="text-[var(--text-muted)] mb-5">
                Ton espace est pr√™t. Authentifie-toi avec Google pour acc√©der √† la conversation.
              </p>
              <button
                onClick={handleGoogleLogin}
                className="w-full h-12 rounded-lg bg-[var(--surface-2)] text-[var(--text)] border border-[var(--image-border)] hover:bg-[color-mix(in_srgb,var(--surface-2)_93%,black_7%)] hover:shadow-sm transition-all duration-200 ease-out font-medium"
              >
                Se connecter avec Google
              </button>
            </div>
          </div>
        </div>
      )}
      {drawerOpen && (
  <div className="sm:hidden fixed inset-0 z-50">
    <div className="absolute inset-0 bg-[var(--scrim-40)]" onClick={() => setDrawerOpen(false)} />
    <div className="absolute left-0 top-0 h-full w-64 bg-[var(--surface-2)] border-r border-[var(--border)] shadow-2xl p-3">
      <div className="flex items-center justify-between mb-4">
        <div className="h-10 w-10 rounded-xl bg-[var(--surface-3)] border border-[var(--image-border)] flex items-center justify-center text-lg font-black">N</div>
        <button
          onClick={() => setDrawerOpen(false)}
          className="h-10 w-10 rounded-lg flex items-center justify-center text-[var(--text-muted)] hover:bg-[var(--surface-3)]"
          aria-label="Fermer"
        >
          <X size={20} />
        </button>
      </div>
    </div>
  </div>
)}

    </main>
  );
}
